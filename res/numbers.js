

const mod = (a,b) => {
	if (a>=0 && b>=0 || a<0 && b<0) return Math.floor(a/b)
	else return Math.ceil(a/b)
}

function numbers(){

	console.log("----------------------------------------------NUMBERS");


	console.log("1.0+2.5+2.5:");
	console.log(1.0+2.5+2.5); // => 6 => не 6.0
	console.log("1+5:");
	console.log(1+5); // => 6



	// toString()
	// toString(radix)
	console.log("Number(29).toString(16):");
	console.log( Number(29).toString(16) ); // => 1d

	console.log("Number(29.55).toString(16):");
	console.log( Number(29.55).toString(16) ); // => 1d.8ccccccccccd

	console.log("2^32 = 4294967296 = 1 00000000 00000000 00000000 00000000:");
	console.log( 4294967296 ); // => 0
	console.log( "bin: " + (4294967296).toString(2) ) // => bin: 100000000000000000000000000000000

	console.log("-2^32 = -4294967296 = -1 00000000 00000000 00000000 00000000:");
	console.log( -4294967296 ); // => 0
	console.log( "bin: " + (-4294967296).toString(2) ) // => bin: -100000000000000000000000000000000






	// Побитовый сдвиг влево.

	// У сдвига меньший приоритет, чем у +, но больший чем у |.

	// С самого права в число вдвигаются 0, остальные биты просто сдвигаются влево, левй бит пропадает.

	// Целые числа представляются как знаковый int32, включая представление в дополнительном коде для отрицательных:
	// Берётся целое число, его модуль переводится в binary code (остаются только младшие 32 бита), 
	// потом если был минус, то эти 32 бита переводятся в доп код (инверсия всех 32 битов, затем+1).
	// Если число дробное, то сначала дробная часть просто откидывается


	// если количество сдвига больше длины int32, то x<<n => x<<(n%32)

	console.log("(16 = 00000000 00000000 00000000 00010000)<<1:");
	console.log( 16<<1 ); // => 32
	console.log( "bin: " + (16<<1).toString(2) )

	console.log("(-16 => доп код 11111111 11111111 11111111 11110000)<<1:");
	console.log( -16<<1 ); // => -32

	console.log("2^31-1 = 2147483647 = 01111111 11111111 11111111 11111111:");
	console.log( 2147483647 ); // => 2147483647
	console.log( "bin: " + (2147483647).toString(2) )

	console.log("(2^31-1 = 2147483647 = 01111111 11111111 11111111 111111110)<<1:");
	console.log( 2147483647<<1 ); // => -2

	console.log("(2^31 = 2147483648 = 10000000 00000000 00000000 00000000)<<1:");
	console.log( 2147483648<<1 ); // => 0
	console.log( "bin: " + (2147483648<<1).toString(2) )

	console.log("(2^31+1 = 2147483649 = 10000000 00000000 00000000 0000001)<<1:");
	console.log( 2147483649<<1 ); // => 2
	console.log( "bin: " + (2147483649<<1).toString(2) )

	console.log("(2^32 = 4294967296 = 1 00000000 00000000 00000000 00000000)<<1:");
	console.log( 4294967296<<1 ); // => 0
	console.log( "bin: " + (4294967296<<1).toString(2) ) // => bin: 0



	console.log("(2^34-1 = 17179869183 = 11 11111111 11111111 11111111 11111111)<<0:");
	console.log( 17179869183<<0 ); // => -1

	console.log("(-2^34-1 = -17179869183 = -11 11111111 11111111 11111111 11111111)<<0:");
	console.log( -17179869183<<0 ); // => 1

	console.log("(-2^34-1 = -17179869183 = -11 11111111 11111111 11111111 11111110)<<0:");
	console.log( -17179869182<<0 ); // => 2



	console.log("4<<32");
	console.log(4<<32) // 6

	console.log("(2^30+1 = 1073741825 = 01000000 00000000 00000000 00000001)<<33:");
	console.log( 1073741825<<1 ); // => -2147483646



	console.log("4.25<<0");
	console.log(4.25<<0) // 4

	console.log("4.99<<0");
	console.log(4.99<<0) // 4

	console.log("-4.99<<1");
	console.log(-4.99<<1) // -8

	console.log("4.25<<1");
	console.log(4.25<<1) // 8

	console.log("(2^31 = 2147483648 = 10000000 00000000 00000000 00000000)<<0:");
	console.log( 2147483648<<0 ); // => -2147483648





	console.log("-----------------------------------------------------");

}